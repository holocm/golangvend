#!/bin/bash
#
# golangvend - no-bullshit vendoring of Golang dependencies
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# golangvend. If not, see <http://www.gnu.org/licenses/>.
#

set -euo pipefail

DELETE_UNUSED_REPOS=0
for ARG in "$@"; do
  case "${ARG}" in
    --delete-unused)
      DELETE_UNUSED_REPOS=1
      ;;
    *)
      echo "Usage: golangvend [--delete-unused]" >&2
      exit 1
      ;;
  esac
done


# preparations
mkdir -p vendor/pins
CACHE_PATH="${PWD}/.golangvend-cache"

# macOS support (need to use coreutils versions of find(1) and sha256sum(1))
if hash gfind &>/dev/null; then
  find() {
    gfind "$@"
  }
fi
if !hash sha256sum &>/dev/null; then
  if hash gsha256sum &>/dev/null; then
    sha256sum() {
      gsha256sum "$@"
    }
  else
    sha256sum() { # fallback for macOS without coreutils
      shasum -a 256 "$@"
    }
  fi
fi

# Given a string, print its SHA256 checksum.
hash_string() {
  echo "${1}" | sha256sum | cut -d' ' -f1
}

# Vendor all dependencies for the package in the given path.
vendor_deps() {
  local PKG_PATH="$1"
  printf "\e[1;34m[ scan ]\e[0m %s\n" "${PKG_PATH}"
  if [ ! -d "${PKG_PATH}" ]; then
    echo "error: directory not found" >&2
    return 1
  fi

  # enumerate source files to consider
  for SOURCE_FILE in "${PKG_PATH}"/*.go; do
    # do not pull in dependencies for unit tests of vendored dependencies
    if [[ "${PKG_PATH}" == vendor/* && "${SOURCE_FILE}" == *_test.go ]]; then
      continue
    fi

    # scan for external dependencies
    # (sed selects import statements, cut selects the package names,
    # grep selects external packages (except for those autogenerated from
    # Protobuf declarations)
    for IMPORTED_PATH in $(sed -n '/^import (/,/)/p;/^import "/p' "${SOURCE_FILE}" | grep '"' | cut -d'"' -f2 | grep -E '\w+\.' | grep -v '\.pb$'); do
      # do not import a dependency more than once
      local FLAG_NAME="IMPORT_DONE_$(hash_string "${IMPORTED_PATH}")"
      set +u
      if [ "${!FLAG_NAME}" = 1 ]; then
        continue
      fi
      set -u
      eval "${FLAG_NAME}=1"

      # get this dependency
      if [ ! -d "${CACHE_PATH}/src/${IMPORTED_PATH}" ]; then
        GOPATH="${CACHE_PATH}" GOBIN="" go get -d "${IMPORTED_PATH}"
      fi

      # we want to vendor the whole external repository, not just the directory
      # inside it that we happen to include, so find the import name of the repo
      local IMPORTED_PATH_WITH_SLASH="${IMPORTED_PATH}/"
      local PATH_INSIDE_REPO="$(git -C "${CACHE_PATH}/src/${IMPORTED_PATH}" rev-parse --show-prefix)"
      local REPO_PATH="${IMPORTED_PATH_WITH_SLASH%/${PATH_INSIDE_REPO}}"
      # allow the user to skip vendoring certain dependencies
      local SKIP_FILE="vendor/skip/${REPO_PATH//\//_}"
      if [ -f "${SKIP_FILE}" ]; then
        printf "\e[1;33m[ skip ]\e[0m %s\n" "${REPO_PATH}"
      else
        vendor_repo "${REPO_PATH}"
        vendor_deps "vendor/${IMPORTED_PATH}"
      fi
    done
  done
}

# Copy the given repo into the vendor/ directory.
vendor_repo() {
  local REPO_PATH="$1"

  # do not vendor a repo more than once
  local FLAG_NAME="VENDOR_DONE_$(hash_string "${REPO_PATH}")"
  set +u
  if [ "${!FLAG_NAME}" = 1 ]; then
    return 0
  fi
  set -u
  eval "${FLAG_NAME}=1"

  printf "\e[1;36m[vendor]\e[0m %s\n" "${REPO_PATH}"

  # make sure that the cache is up-to-date
  local REPO_PATH_IN_CACHE="${CACHE_PATH}/src/${REPO_PATH}"
  git -C "${REPO_PATH_IN_CACHE}" fetch origin >/dev/null

  # pin the current version in vendor/pins if there is no pin yet
  local PIN_FILE="vendor/pins/${REPO_PATH//\//_}"
  if [ ! -f "${PIN_FILE}" ]; then
    git -C "${REPO_PATH_IN_CACHE}" rev-parse origin/master > "${PIN_FILE}"
  fi

  # vendor the source code into the vendor/ directory
  rm -rf -- "vendor/${REPO_PATH}/"
  git -C "${REPO_PATH_IN_CACHE}" archive --prefix="vendor/${REPO_PATH}/" "$(cat "${PIN_FILE}")" | tar xf -

  # flag this dependency as in use
  touch "vendor/${REPO_PATH}/.golangvend-keep"
}

# protect packages that are provided by this repo from being vendored
eval "$(go list ./... | grep -v /vendor/ | while read REPO_PATH; do
  echo "export IMPORT_DONE_$(hash_string "${REPO_PATH}")=1"
  echo "export VENDOR_DONE_$(hash_string "${REPO_PATH}")=1"
done)"

# vendor all dependencies, recursively
find * \( -name .golangvend-cache -o -name vendor \) -prune -o -name \*.go -exec dirname {} \; | sort -u | while read PKG_PATH; do
  vendor_deps "${PKG_PATH}"
done

# report unused imports
for REPO_DIR in $(find vendor -type d \( \( -exec test -f {}/.golangvend-keep \; -prune \) -o -print \)); do
  REPO_PATH="${REPO_DIR#vendor/}"
  PIN_FILE="vendor/pins/${REPO_PATH//\//_}"
  if [ -f "${PIN_FILE}" ]; then
    if [ "${DELETE_UNUSED_REPOS}" = 1 ]; then
      printf "\e[1;31m[remove]\e[0m %s\n" "${REPO_DIR}"
      git rm -r -- "${PIN_FILE}" "${REPO_DIR}"
    else
      printf "\e[1;33m[unused]\e[0m %s (use \`golangvend --delete-unused\`)\n" "${REPO_PATH}"
    fi
  fi
done

# cleanup
find vendor -name .golangvend-keep -delete
